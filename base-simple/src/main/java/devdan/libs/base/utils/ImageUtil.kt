package devdan.libs.base.utilsimport android.content.Contextimport android.graphics.Bitmapimport android.graphics.BitmapFactoryimport android.graphics.Matriximport android.os.Environmentimport androidx.exifinterface.media.ExifInterfaceimport kotlinx.coroutines.runBlockingimport java.io.ByteArrayOutputStreamimport java.io.Fileimport java.io.FileOutputStreamimport java.io.IOExceptionimport java.text.SimpleDateFormatimport java.util.*object ImageUtil {    private const val FILENAME_FORMAT = "yyyy-MM-dd-HH-mm-ss-SSS"    const val TAG = "IMAGE"    fun getOutputDirectory(context: Context, subFolderName: String? = null): File {        val mediaDir = context.getExternalFilesDir(Environment.DIRECTORY_PICTURES).let {            val dirName = context.applicationInfo.name ?: "name"            if (subFolderName.isNullOrEmpty()) {                File(it, dirName).apply { mkdirs() }            } else {                val dir = File(it, dirName)                File(dir, subFolderName).apply {                    mkdirs()                }            }        }        return if (mediaDir.exists())            mediaDir else context.filesDir    }    fun getImageFileName(): String {        return "${            SimpleDateFormat(                FILENAME_FORMAT, Locale.getDefault()            ).format(System.currentTimeMillis())        }.jpg"    }    private fun getCompressFileName(): String {        return "compressed_${            SimpleDateFormat(                FILENAME_FORMAT, Locale.getDefault()            ).format(System.currentTimeMillis())        }.jpg"    }    fun getCompressed(context: Context, path: String): File? = runBlocking {        if (path.isEmpty()) {            return@runBlocking null        }        val src = BitmapFactory.decodeFile(path)        val origWidth = src.width        val origHeight = src.height        Logger.d(TAG, "origin : $origWidth X $origHeight")        val compressed: File        val destWidth = 640        if (origWidth > destWidth) {            val quality = ((destWidth.toDouble() / origWidth.toDouble()) * 100).toInt()            Logger.d(TAG, "quality : $quality")            // picture is wider than we want it, we calculate its target height            val destHeight: Int = origHeight / (origWidth / destWidth)            // we create an scaled bitmap so it reduces the image, not just trim it            var resizedBitmap = Bitmap.createScaledBitmap(src, destWidth, destHeight, false)            resizedBitmap = rotate(getExifOrientation(path), resizedBitmap)            val outStream = ByteArrayOutputStream()            resizedBitmap.compress(Bitmap.CompressFormat.JPEG, quality, outStream)            // we save the file, at least until we have made use of it            compressed = File(getOutputDirectory(context), getCompressFileName())            compressed.createNewFile()            //write the bytes in file            val fo = FileOutputStream(compressed)            fo.write(outStream.toByteArray())            // remember close de FileOutput            fo.close()            return@runBlocking compressed        } else {            return@runBlocking File(path)        }    }    private fun getExifOrientation(filepath: String): Int {        var degree = ExifInterface.ORIENTATION_UNDEFINED        var exif: ExifInterface? = null        try {            exif = ExifInterface(filepath)        } catch (ex: IOException) {            Logger.e(TAG, ex.message, ex)        }        if (exif != null) {            val orientation: Int = exif.getAttributeInt(                ExifInterface.TAG_ORIENTATION,                ExifInterface.ORIENTATION_UNDEFINED            )            Logger.e(TAG, "orientation is $orientation")            if (orientation != ExifInterface.ORIENTATION_UNDEFINED) {                degree = orientation            }        }        return degree    }    private fun rotate(value: Int, bm: Bitmap?): Bitmap? {        if (bm == null) return null        var result: Bitmap = bm        if (value > 0) {            val matrix: Matrix = getRotateMatrix(value)            result = Bitmap.createBitmap(bm, 0, 0, bm.width, bm.height, matrix, true)            Logger.e("IMAGE", "before : ${bm.width} : ${bm.height}")            Logger.e("IMAGE", "after : ${result.width} : ${result.height}")            if (bm != result) {                bm.recycle()            }        }        return result    }    private fun getRotateMatrix(ori: Int): Matrix {        val matrix = Matrix()        when (ori) {            0 -> matrix.setRotate(90F)            ExifInterface.ORIENTATION_FLIP_HORIZONTAL -> matrix.setScale(-1F, 1F)            ExifInterface.ORIENTATION_ROTATE_180 -> matrix.setRotate(180F)            ExifInterface.ORIENTATION_FLIP_VERTICAL -> {                matrix.setRotate(180F)                matrix.postScale(-1F, 1F)            }            ExifInterface.ORIENTATION_TRANSPOSE -> {                matrix.setRotate(90F)                matrix.postScale(-1F, 1F)            }            ExifInterface.ORIENTATION_ROTATE_90 -> matrix.setRotate(90F)            ExifInterface.ORIENTATION_TRANSVERSE -> {                matrix.setRotate(-90F)                matrix.postScale(-1F, 1F)            }            ExifInterface.ORIENTATION_ROTATE_270 -> matrix.setRotate(-90F)        }        return matrix    }}